---
title: "factorMerger: set of tools to support results from post hoc testing"
author: "Agnieszka Sitko"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: 
            collapsed: false
        theme: united
        highlight: tango    
        collapsed: false
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../materials/factorMerger.bib
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", warning = FALSE, message = FALSE,
                      fig.height = 5, fig.width = 7)
```

# Introduction

The aim of `factorMerger` is to provide set of tools to support results from post hoc comparisons. Post hoc testing is an analysis performed after running *ANOVA* to examine differences between group means (of some response numeric variable) for each pair of groups (groups are defined by a factor variable).

This project arose from the need to create a method of post hoc testing which gives the hierarchical interpretation of relations between groups means. Thereby, for a given significance level we may divide groups into nonoverlapping clusters. 

# Algorithm inputs

In the current version the **factorMerger** package supports parametric models: 

- one-dimensional Gaussian (with the argument `family = "gaussian"`),
- multi dimensional Gaussian (with the argument `family = "gaussian"`),
- binomial (with the argument `family = "binomial"`),
- survival (with the argument `family = "survival"`).

Set of hypotheses that are tested during merging may be either comprehensive or limited. This gives two possibilities:

- *all-to-all* (with the argument `successive = FALSE`),
- *successive* (with the argument `successive = TRUE`).

The version *all-to-all* considers all possible pairs of factor levels. In the  *successive* approach factor levels are preliminarily sorted and then only consecutive groups are tested for means equality.

The **factorMerger** package also implements two strategies of a single iteration of the algorithm. They use one of the following:

- *Likelihood Ratio Test* (with the argument `method = "LRT"`),
- *agglomerative clustering with constant distance matrix* [based on the *DMR4glm* algorithm @Proch, with the argument `method = "hclust"`]. 

# Generating samples 

To visualize functionalities of `factorMerger` we use samples for which response variable is generated from one of the distributions listed above and corresponding factor variable is sampled uniformly from a finite set of a size $k$. 

To do so, we may use function `generateSample` or `generateMultivariateSample`.

```{r}
library(factorMerger) 
library(knitr)
library(dplyr)
randSample <- generateMultivariateSample(N = 100, k = 10, d = 3)
```

# Merging factors

`mergeFactors` is a function that performs hierarchical post hoc testing. As arguments it takes:

 - matrix/data.frame/vector with numeric response,
 - factor vector defining groups.
 
By default (with argument `abbreviate = TRUE`) factor levels are abbreviated and surrounded with brackets.

## Multi-dimensional Gaussian model


```{r}
fmAll <- mergeFactors(randSample$response, randSample$factor)
```

`mergeFactors` outputs with information about the 'merging history'. 

```{r}
mergingHistory(fmAll, showStats = TRUE) %>% kable()
```

Each row of the above frame describes one step of the merging algorithm. First two columns specify which groups were merged in the iteration, columns *model* and *GIC* gather loglikelihood and Generalized Information Criterion for the model after merging. Last two columns are p-values for the *Likelihood Ratio Test* -- against the full model and against the previous one.


```{r}
plotTree(fmAll)
```

If we set `successive = TRUE` then at the beginning one dimensional response is fitted using `isoMDS{MASS}`. Then, in each step only groups whose means are closed are compared.

```{r}
fm <- mergeFactors(randSample$response, randSample$factor, successive = TRUE, method = "hclust")
mergingHistory(fm) %>% kable()
```


We may plot results using functions `plotTree`. `plotTree` enables to specify what should be displayed on x axis (either column 'model' or logarithm of 'pval').

```{r, fig.height = 5, fig.width = 7}
plotTree(fm, stat = "model")
```

```{r, fig.height = 5, fig.width = 7}
plotTree(fmAll, "pval", alpha = 0.5)
```

It also takes logical argument `simplify`, which controls how x axis is displayed. If `simplify = FALSE` then each node is connected the mean/mean of isoMDS projection/proportion of observations respresented by the node. Otherwise nodes are plotted using equal intervals on the x axis. As default we use `simplify = TRUE`. 

```{r}
plotTree(fm, simplify = FALSE)
```



We may also want to visualize dependent variables together with created tree. `factorMergers` introduces two functions for this purpose:

 - `plotProfile` (resulting in rank plot),
 - `plotHeatmap`.
 
```{r, fig.height = 5, fig.width = 7}
appendToTree(fm, plotProfile(fm))
```

In the above plots colours are connected with the group. The plot on the right shows means rankings for all variables included in the algorithm. 

```{r, fig.height = 5, fig.width = 7}
appendToTree(fm, plotHeatmap(fm))
```

The heatmap on the right shows means of all variables taken into analysis by groups.


It is also possible to plot *GIC* together with the merging path plot.

```{r}
appendToTree(fm, plotGIC(fm))
```


## One-dimensional Gaussian model

```{r}
oneDimRandSample <- generateSample(1000, 10)
```
```{r}
oneDimFm <- mergeFactors(oneDimRandSample$response, oneDimRandSample$factor, method = "hclust")
mergingHistory(oneDimFm) %>% kable()
```
```{r}
plotTree(oneDimFm, simplify = FALSE)
```

```{r}
appendToTree(oneDimFm, plotBoxplot(oneDimFm))
```

```{r}
appendToTree(oneDimFm, plotMeansAndStds(oneDimFm))
```

## Binomial model


If `family = "binomial"` response must have to values: `0` and `1` (`1` is interpreted as success).

```{r}
binomRandSample <- generateSample(1000, 10, distr = "binomial")
table(binomRandSample$response, binomRandSample$factor)
```

```{r}
binomFm <- mergeFactors(binomRandSample$response, binomRandSample$factor, family = "binomial", successive = TRUE)
mergingHistory(binomFm) %>% kable()
```

```{r}
plotTree(binomFm)
```

```{r}
plotTree(binomFm, simplify = FALSE)
```

```{r}
appendToTree(binomFm, plotProportion(binomFm))
```


## Survival model
 
If `family = "survival"` response must be of a class `Surv`.
 
```{r}
library(survival)
data(veteran)
survResponse <- Surv(time = veteran$time, 
                 event = veteran$status)
survivalFm <- mergeFactors(response = survResponse, 
                   factor = veteran$celltype, 
                   family = "survival")
```

```{r}
mergingHistory(survivalFm) %>% kable()
```


```{r}
plotTree(survivalFm, "model")
```

```{r}
plotTree(survivalFm, "pval", simplify = FALSE)
```

```{r}
appendToTree(survivalFm, plotSurvival(survivalFm))
```

#Bibliography
